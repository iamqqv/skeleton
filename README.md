Skeleton App for quick development start with Symfony 5.3, SCSS, Bootstrap5 & VueJS

Taken from https://www.twilio.com/blog/get-started-docker-symfony

Clone this repository, run `docker-compose up -d` and start coding.

## How to get up and running:

1. Clone this repository
2. Stop all running Docker Containers so there's no same ports problem
3. move into the `app/` directory via `cd app/` and copy `.env` file, create a `.env.local` file and change the `DATABASE_URL` parameter to `DATABASE_URL="mysql://root:secret@database:3306/symfony_docker?serverVersion=8.0"`
4. run `docker-compose up -d` (for detached mode) in your terminal
5. connect to your php container via `docker-compose exec php bash`
   1. run `composer install` or `composer update` to install dependencies
6. Exit the php container and move into the app directory via `cd app/` run `yarn install` in the to install javascript dependencies
7. run `yarn encore dev` to build all necessary styles
8. visit http://localhost:8080/

## Troubleshooting
If there's an error occuring like:

`error @symfony/webpack-encore@1.5.0: The engine "node" is incompatible with this module. Expected version "^10.19.0 || ^12.0.0 || >=14.0.0". Got "10.16.0"`

you should update your node version: https://nodejs.org/en/

## Frontend
How to add **SCSS**:
Inside `app/assets/styles` there are the scss files that you can modify. To see your changes, just run `yarn encore dev (--watch)`

How to add **Vanilla JS**:
Inside `app/assets/js` there are the scss files that you can modify. To see your changes, just run `yarn encore dev (--watch)`

You can either use Vanilla JavaScript, for example in the already working `vanilla.js` file or you can code in vuejs `App.vue`.


## Docker configuration:

Because the different containers that compose our application need to communicate, we will use Docker Compose to define them.

`docker-compose.yml`

This file will hold all the configuration for the containers to be built in our application stack, from how the containers are to be built to the networks and volumes accessible to the containers.

### Database container 

`version` refers to the schema version.

`services` defines the list of containers our application stack will consist of.

`container_name` sets the actual name of the container when it runs, rather than letting Docker Compose generate it.

`image` lets Docker know what image (blueprint) we want to build the container from. In this case, we've specified **mysql:8.0** because we want to use version 8 of MySQL.

`command` specifies the authentication plugin to be used by MySQL for authenticating users. 

Using the `environment` key, we can specify environment variables such as the database's name, user, and password, as well as the root user's password.

We need a port to connect to our database. Using the `ports` key, we specify a port on our local development machine and map it to a port on the container which will be used to handle database connections.

**_Note: Port 4306 was specified in the event that MySQL service is already running on your computer._**

We declare a `volume` in this case so that our database won't be lost when the containers are destroyed or rebuilt.


### PHP container

Unlike the database container, we need to specify some additional instructions to set up our PHP container. To do this, we will build the PHP container from a Dockerfile.

**_Note: In the last two lines of skeleton/php/Dockerfile, please replace "you@example.com" with your email address and "Your Name" with your actual name._**

In addition to scaffolding a container from the PHP-FPM image, we will do the following:

1. Install the PHP extensions Symfony depends on.
2. Set the working directory of the container to /var/www/symfony_docker
3. Install composer
4. Install the Symfony CLI

Instead of specifying an image, we specify a build context. This way, when the docker-compose command is run, the instructions declared in `php/Dockerfile` will be used to build the container.

Port 9000 on the computer is mapped to `port 9000` on the container, just as we mapped a port on the computer to a port on the container for the MySQL database.

We declare a volume again to persist the data generated by the container. In this case, our Symfony application will be created in the /var/www/symfony_docker directory of the PHP container. However, it will be persisted in the app directory in the project.

Finally, the `depends_on` key was used. This creates a dependency between the PHP and database containers instructing Docker to build and start the database container **before** the PHP container


### NGINX container

This is a basic Nginx configuration required for running a Symfony project. The only thing done differently is the specification for `fastcgi_pass`. Notice that in this case we specify port `9000` of the PHP container, because this is the default port that PHP-FPM listens on for requests.


## Connect to your local database with Sequel Ace

Host: 127.0.0.1
Username: symfony
Password: symfony
Datbase: symfony_docker
Port: 4306
